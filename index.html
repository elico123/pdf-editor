<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Offline PDF Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .loader { border-top-color: #3498db; -webkit-animation: spin 1s linear infinite; animation: spin 1s linear infinite; }
        @-webkit-keyframes spin { 0% { -webkit-transform: rotate(0deg); } 100% { -webkit-transform: rotate(360deg); } }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #page-container canvas { box-shadow: 0 4px 12px rgba(0,0,0,0.15); margin-bottom: 1rem; }
        .thumbnail-item { border: 2px solid transparent; transition: border-color 0.2s; }
        .thumbnail-item.selected { border-color: #3b82f6; }
        .sortable-ghost { opacity: 0.4; background: #c7d2fe; }
        .redaction-box { position: absolute; border: 2px dashed red; background-color: rgba(255, 0, 0, 0.3); }
        /* Drawer styles */
        #sidebar { transform: translateX(-100%); }
        #sidebar.open { transform: translateX(0); }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 flex flex-col h-screen">

    <!-- Header -->
    <header class="bg-white shadow-md p-4 flex items-center justify-between z-20">
        <div class="flex items-center space-x-4">
            <button id="menu-btn" class="p-2 rounded-md hover:bg-gray-200 transition hidden">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" />
                </svg>
            </button>
            <h1 class="text-xl md:text-2xl font-bold text-gray-800">PDF Editor</h1>
        </div>
        <div class="flex items-center space-x-2">
            <input type="file" id="file-input" class="hidden" accept="application/pdf" multiple>
            <button id="open-pdf-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg transition duration-300">Open PDF</button>
            <button id="save-pdf-btn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition duration-300 hidden">Save</button>
            <button id="print-pdf-btn" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg transition duration-300 hidden">Print</button>
        </div>
    </header>

    <!-- Drawer Overlay -->
    <div id="drawer-overlay" class="fixed inset-0 bg-black bg-opacity-50 z-20 hidden"></div>

    <!-- Drawer/Sidebar -->
    <aside id="sidebar" class="fixed top-0 left-0 h-full w-64 bg-white p-4 overflow-y-auto border-r border-gray-200 z-30 transition-transform duration-300 ease-in-out">
        <h2 class="text-lg font-semibold mb-4">Tools & Pages</h2>
        
        <!-- Tools -->
        <div class="space-y-2 mb-6">
            <button id="tool-merge" class="w-full text-left bg-gray-200 hover:bg-gray-300 text-gray-700 font-semibold py-2 px-4 rounded-lg transition">Merge Documents</button>
            <button id="tool-split" class="w-full text-left bg-gray-200 hover:bg-gray-300 text-gray-700 font-semibold py-2 px-4 rounded-lg transition">Split Document</button>
            <button id="tool-add-text" class="w-full text-left bg-gray-200 hover:bg-gray-300 text-gray-700 font-semibold py-2 px-4 rounded-lg transition">Add Text</button>
            <button id="tool-redact" class="w-full text-left bg-gray-200 hover:bg-gray-300 text-gray-700 font-semibold py-2 px-4 rounded-lg transition">Redact</button>
        </div>

        <!-- Pages -->
        <h3 class="text-md font-semibold mb-2">Pages (Drag to Sort)</h3>
        <div id="thumbnails-container" class="space-y-2">
            <!-- Thumbnails will be injected here -->
        </div>
    </aside>

    <!-- Main Content -->
    <main class="flex-1 flex flex-col overflow-hidden">
        <!-- PDF Viewer -->
        <div id="viewer-container" class="flex-1 bg-gray-200 p-4 overflow-y-auto flex items-center justify-center">
            <div id="welcome-message" class="text-center">
                <svg class="mx-auto h-12 w-12 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true">
                    <path vector-effect="non-scaling-stroke" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                </svg>
                <h3 class="mt-2 text-sm font-medium text-gray-900">No PDF selected</h3>
                <p class="mt-1 text-sm text-gray-500">Get started by opening a PDF file.</p>
            </div>
            <div id="page-container" class="relative">
                <!-- PDF pages will be rendered here -->
            </div>
        </div>
    </main>

    <!-- Modal/Loader -->
    <div id="loader-overlay" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="loader ease-linear rounded-full border-8 border-t-8 border-gray-200 h-32 w-32"></div>
        <p id="loader-text" class="text-white text-lg ml-4">Loading...</p>
    </div>
    
    <!-- Service Worker Registration -->
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/service-worker.js')
                    .then(registration => console.log('ServiceWorker registration successful with scope: ', registration.scope))
                    .catch(error => console.log('ServiceWorker registration failed: ', error));
            });
        }
    </script>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // PDF.js worker configuration
            pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js`;
            
            // DOM Elements
            const fileInput = document.getElementById('file-input');
            const openPdfBtn = document.getElementById('open-pdf-btn');
            const savePdfBtn = document.getElementById('save-pdf-btn');
            const printPdfBtn = document.getElementById('print-pdf-btn');
            const menuBtn = document.getElementById('menu-btn');
            const sidebar = document.getElementById('sidebar');
            const drawerOverlay = document.getElementById('drawer-overlay');
            const viewerContainer = document.getElementById('viewer-container');
            const pageContainer = document.getElementById('page-container');
            const thumbnailsContainer = document.getElementById('thumbnails-container');
            const welcomeMessage = document.getElementById('welcome-message');
            const loaderOverlay = document.getElementById('loader-overlay');
            const loaderText = document.getElementById('loader-text');
            
            // Tool Buttons
            const toolMergeBtn = document.getElementById('tool-merge');
            const toolSplitBtn = document.getElementById('tool-split');
            const toolAddTextBtn = document.getElementById('tool-add-text');
            const toolRedactBtn = document.getElementById('tool-redact');

            // App State
            let pdfDoc = null;
            let pdfBytes = null;
            let pageOrder = [];
            let activeTool = null;
            let redactionAreas = [];

            // --- DRAWER/MENU LOGIC ---
            const openDrawer = () => {
                sidebar.classList.add('open');
                drawerOverlay.classList.remove('hidden');
            };

            const closeDrawer = () => {
                sidebar.classList.remove('open');
                drawerOverlay.classList.add('hidden');
            };

            menuBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                if (sidebar.classList.contains('open')) {
                    closeDrawer();
                } else {
                    openDrawer();
                }
            });

            drawerOverlay.addEventListener('click', closeDrawer);

            // --- CORE PDF HANDLING ---

            const loadPdf = async (file) => {
                showLoader('Loading PDF...');
                const arrayBuffer = await file.arrayBuffer();
                pdfBytes = new Uint8Array(arrayBuffer);
                
                await loadPdfFromBytes(pdfBytes);

                welcomeMessage.classList.add('hidden');
                menuBtn.classList.remove('hidden');
                savePdfBtn.classList.remove('hidden');
                printPdfBtn.classList.remove('hidden');
                
                hideLoader();
            };
            
            const loadPdfFromBytes = async (bytes) => {
                 showLoader('Rendering PDF...');
                 pdfBytes = bytes;
                 pdfDoc = await pdfjsLib.getDocument({ data: bytes }).promise;
                 pageOrder = Array.from({ length: pdfDoc.numPages }, (_, i) => i + 1);
                 await renderAllPages();
                 await renderThumbnails();
                 hideLoader();
            }

            const renderPage = async (pageNum, container) => {
                const page = await pdfDoc.getPage(pageNum);
                const scale = viewerContainer.clientWidth / page.getViewport({ scale: 1.0 }).width * 0.9;
                const viewport = page.getViewport({ scale: scale });
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.height = viewport.height;
                canvas.width = viewport.width;
                canvas.dataset.pageNum = pageNum;
                
                const renderContext = {
                    canvasContext: context,
                    viewport: viewport
                };
                await page.render(renderContext).promise;
                container.appendChild(canvas);
                return canvas;
            };

            const renderAllPages = async () => {
                pageContainer.innerHTML = '';
                for (const pageNum of pageOrder) {
                    await renderPage(pageNum, pageContainer);
                }
            };
            
            const renderThumbnails = async () => {
                thumbnailsContainer.innerHTML = '';
                for (let i = 0; i < pageOrder.length; i++) {
                    const pageNum = pageOrder[i];
                    const page = await pdfDoc.getPage(pageNum);
                    const viewport = page.getViewport({ scale: 0.3 });
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;

                    const renderContext = {
                        canvasContext: context,
                        viewport: viewport
                    };
                    await page.render(renderContext).promise;
                    
                    const thumbItem = document.createElement('div');
                    thumbItem.classList.add('thumbnail-item', 'p-1', 'rounded-md', 'cursor-pointer', 'relative');
                    thumbItem.dataset.originalIndex = pageNum;
                    thumbItem.dataset.currentIndex = i;
                    
                    const pageNumberLabel = document.createElement('span');
                    pageNumberLabel.textContent = i + 1;
                    pageNumberLabel.classList.add('absolute', 'top-1', 'left-1', 'bg-blue-500', 'text-white', 'text-xs', 'font-bold', 'px-1.5', 'py-0.5', 'rounded');
                    
                    thumbItem.appendChild(canvas);
                    thumbItem.appendChild(pageNumberLabel);
                    thumbnailsContainer.appendChild(thumbItem);
                }
            };

            // --- EVENT LISTENERS ---

            openPdfBtn.addEventListener('click', () => fileInput.click());
            
            fileInput.addEventListener('change', async (e) => {
                if (e.target.files.length > 0) {
                    if(activeTool === 'merge') {
                        await handleMerge(e.target.files);
                        activeTool = null;
                    } else {
                        await loadPdf(e.target.files[0]);
                    }
                }
            });

            savePdfBtn.addEventListener('click', async () => {
                showLoader('Saving PDF...');
                const { PDFDocument } = PDFLib;
                // Create a new document from the original bytes, then copy the reordered pages
                const originalDoc = await PDFDocument.load(pdfBytes);
                const finalDoc = await PDFDocument.create();
                const pageIndicesToCopy = pageOrder.map(p => p - 1);
                const copiedPages = await finalDoc.copyPages(originalDoc, pageIndicesToCopy);
                copiedPages.forEach(page => finalDoc.addPage(page));

                // Apply redactions if any
                if (redactionAreas.length > 0) {
                    const { rgb } = PDFLib;
                    for (const area of redactionAreas) {
                        // Find the new index of the page after sorting
                        const originalPageIndex = pageOrder.indexOf(area.originalPageNum);
                        if (originalPageIndex !== -1) {
                            const page = finalDoc.getPage(originalPageIndex);
                            page.drawRectangle({
                                x: area.x,
                                y: area.y,
                                width: area.width,
                                height: area.height,
                                color: rgb(0, 0, 0),
                            });
                        }
                    }
                }

                const finalPdfBytes = await finalDoc.save();
                downloadBlob(finalPdfBytes, `edited-${fileInput.files[0]?.name || 'document.pdf'}`);
                hideLoader();
            });

            printPdfBtn.addEventListener('click', async () => {
                // To print correctly, we must save the current state (with reorders etc.) to a blob first
                showLoader('Preparing for print...');
                const { PDFDocument } = PDFLib;
                const originalDoc = await PDFDocument.load(pdfBytes);
                const finalDoc = await PDFDocument.create();
                const pageIndicesToCopy = pageOrder.map(p => p - 1);
                const copiedPages = await finalDoc.copyPages(originalDoc, pageIndicesToCopy);
                copiedPages.forEach(page => finalDoc.addPage(page));
                const finalPdfBytes = await finalDoc.save();
                hideLoader();

                const blob = new Blob([finalPdfBytes], { type: 'application/pdf' });
                const url = URL.createObjectURL(blob);
                const iframe = document.createElement('iframe');
                iframe.style.display = 'none';
                iframe.src = url;
                document.body.appendChild(iframe);
                iframe.onload = () => {
                    setTimeout(() => {
                        iframe.focus();
                        iframe.contentWindow.print();
                    }, 1);
                };
            });

            // --- TOOLS ---
            
            new Sortable(thumbnailsContainer, {
                animation: 150,
                ghostClass: 'sortable-ghost',
                onEnd: async (evt) => {
                    const element = pageOrder.splice(evt.oldIndex, 1)[0];
                    pageOrder.splice(evt.newIndex, 0, element);
                    showLoader('Reordering pages...');
                    await renderAllPages();
                    await renderThumbnails();
                    hideLoader();
                }
            });

            const activateTool = (toolName, message) => {
                 if (!pdfDoc) {
                    alert('Please open a PDF first.');
                    return false;
                }
                activeTool = toolName;
                alert(message);
                closeDrawer();
                return true;
            }

            toolMergeBtn.addEventListener('click', () => {
                if (activateTool('merge', 'Select additional PDF files to merge.')) {
                    fileInput.click();
                }
            });
            
            const handleMerge = async (filesToMerge) => {
                showLoader('Merging PDFs...');
                const { PDFDocument } = PDFLib;
                const mergedPdf = await PDFDocument.load(pdfBytes);

                for (const file of filesToMerge) {
                    const bytes = await file.arrayBuffer();
                    const docToMerge = await PDFDocument.load(bytes);
                    const pages = await mergedPdf.copyPages(docToMerge, docToMerge.getPageIndices());
                    pages.forEach(page => mergedPdf.addPage(page));
                }

                const finalBytes = await mergedPdf.save();
                await loadPdfFromBytes(finalBytes);
                hideLoader();
            };

            toolSplitBtn.addEventListener('click', async () => {
                if (!pdfDoc) { alert('Please open a PDF first.'); return; }
                closeDrawer();
                const splitIndexStr = prompt(`Enter page number to split AFTER (1-${pageOrder.length}):`);
                const splitIndex = parseInt(splitIndexStr);
                
                if (isNaN(splitIndex) || splitIndex <= 0 || splitIndex >= pageOrder.length) {
                    alert('Invalid split point.');
                    return;
                }

                showLoader('Splitting PDF...');
                const { PDFDocument } = PDFLib;
                const baseDoc = await PDFDocument.load(pdfBytes);

                const firstDoc = await PDFDocument.create();
                const firstPagesIndices = pageOrder.slice(0, splitIndex).map(p => p - 1);
                const firstPages = await firstDoc.copyPages(baseDoc, firstPagesIndices);
                firstPages.forEach(p => firstDoc.addPage(p));
                const firstBytes = await firstDoc.save();
                downloadBlob(firstBytes, `part1-${fileInput.files[0].name}`);

                const secondDoc = await PDFDocument.create();
                const secondPagesIndices = pageOrder.slice(splitIndex).map(p => p - 1);
                const secondPages = await secondDoc.copyPages(baseDoc, secondPagesIndices);
                secondPages.forEach(p => secondDoc.addPage(p));
                const secondBytes = await secondDoc.save();
                downloadBlob(secondBytes, `part2-${fileInput.files[0].name}`);
                
                hideLoader();
            });

            toolAddTextBtn.addEventListener('click', () => {
                if (activateTool('add-text', 'Click on a page to add text.')) {
                    pageContainer.style.cursor = 'crosshair';
                }
            });

            toolRedactBtn.addEventListener('click', () => {
                 if (activateTool('redact', 'Click and drag on a page to create a redaction area.')) {
                    pageContainer.style.cursor = 'crosshair';
                    document.querySelectorAll('.redaction-box').forEach(box => box.remove());
                }
            });

            pageContainer.addEventListener('mousedown', async (e) => {
                if (!activeTool || !e.target.matches('canvas')) return;

                const canvas = e.target;
                const rect = canvas.getBoundingClientRect();
                const originalPageNum = parseInt(canvas.dataset.pageNum);
                
                const page = await pdfDoc.getPage(originalPageNum);
                const scale = viewerContainer.clientWidth / page.getViewport({ scale: 1.0 }).width * 0.9;
                const viewport = page.getViewport({ scale: scale });
                
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const pdfX = (x / viewport.width) * page.viewBox[2];
                const pdfY = page.viewBox[3] - ((y / viewport.height) * page.viewBox[3]);

                if (activeTool === 'add-text') {
                    const text = prompt('Enter text to add:');
                    if (text) {
                        showLoader('Adding text...');
                        const { PDFDocument, rgb, StandardFonts } = PDFLib;
                        const pdfLibDoc = await PDFDocument.load(pdfBytes);
                        const helveticaFont = await pdfLibDoc.embedFont(StandardFonts.Helvetica);
                        
                        const pageIndex = pageOrder.indexOf(originalPageNum);
                        const targetPage = pdfLibDoc.getPage(pageIndex);
                        
                        targetPage.drawText(text, {
                            x: pdfX,
                            y: pdfY,
                            font: helveticaFont,
                            size: 12,
                            color: rgb(0, 0, 0),
                        });

                        const finalBytes = await pdfLibDoc.save();
                        await loadPdfFromBytes(finalBytes);
                        hideLoader();
                    }
                    resetTool();
                } else if (activeTool === 'redact') {
                    const startX = e.clientX;
                    const startY = e.clientY;
                    const redactionBox = document.createElement('div');
                    redactionBox.classList.add('redaction-box');
                    viewerContainer.appendChild(redactionBox);

                    const onMouseMove = (moveE) => {
                        const currentX = moveE.clientX;
                        const currentY = moveE.clientY;
                        const left = Math.min(startX, currentX);
                        const top = Math.min(startY, currentY);
                        const width = Math.abs(currentX - startX);
                        const height = Math.abs(currentY - startY);
                        redactionBox.style.left = `${left}px`;
                        redactionBox.style.top = `${top}px`;
                        redactionBox.style.width = `${width}px`;
                        redactionBox.style.height = `${height}px`;
                    };

                    const onMouseUp = (upE) => {
                        document.removeEventListener('mousemove', onMouseMove);
                        document.removeEventListener('mouseup', onMouseUp);
                        
                        const boxRect = redactionBox.getBoundingClientRect();
                        const viewerRect = viewerContainer.getBoundingClientRect();

                        const pdfStartX = ((boxRect.left - rect.left) / viewport.width) * page.viewBox[2];
                        const pdfStartY = page.viewBox[3] - (((boxRect.top - rect.top) + boxRect.height) / viewport.height) * page.viewBox[3];
                        const pdfWidth = (boxRect.width / viewport.width) * page.viewBox[2];
                        const pdfHeight = (boxRect.height / viewport.height) * page.viewBox[3];

                        redactionAreas.push({
                            originalPageNum: originalPageNum,
                            x: pdfStartX,
                            y: pdfStartY,
                            width: pdfWidth,
                            height: pdfHeight
                        });
                        
                        alert(`Redaction area added. Click 'Save' to apply changes permanently.`);
                        resetTool();
                    };

                    document.addEventListener('mousemove', onMouseMove);
                    document.addEventListener('mouseup', onMouseUp);
                }
            });
            
            const resetTool = () => {
                activeTool = null;
                pageContainer.style.cursor = 'default';
            };

            // --- UTILITY FUNCTIONS ---

            const showLoader = (text) => {
                loaderText.textContent = text;
                loaderOverlay.classList.remove('hidden');
            };

            const hideLoader = () => {
                loaderOverlay.classList.add('hidden');
            };

            const downloadBlob = (data, fileName) => {
                const blob = new Blob([data], { type: 'application/pdf' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = fileName;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);
            };
        });
    </script>
</body>
</html>
