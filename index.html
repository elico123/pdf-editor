<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Offline PDF Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .loader { border-top-color: #3498db; -webkit-animation: spin 1s linear infinite; animation: spin 1s linear infinite; }
        @-webkit-keyframes spin { 0% { -webkit-transform: rotate(0deg); } 100% { -webkit-transform: rotate(360deg); } }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        #page-container canvas { 
            box-shadow: 0 4px 12px rgba(0,0,0,0.15); 
            margin-bottom: 1rem; 
            max-width: 100%;
            height: auto;
        }

        .thumbnail-item { border: 2px solid transparent; transition: border-color 0.2s; }
        .thumbnail-item.selected { border-color: #3b82f6; }
        .sortable-ghost { opacity: 0.4; background: #c7d2fe; }
        .redaction-box { 
            position: absolute; 
            background-color: rgba(255, 255, 255, 0.8); 
            border: 2px dashed #333;
            z-index: 10; 
        }
        
        #sidebar { 
            transform: translateX(-100%);
            transition: transform 0.3s ease-in-out;
        }
        #sidebar.open { 
            transform: translateX(0);
        }

        @media (min-width: 768px) {
            #sidebar {
                transform: translateX(0);
            }
            #main-content {
                margin-left: 16rem; /* Same as sidebar width */
            }
            #menu-btn {
                display: none;
            }
            #drawer-overlay {
                display: none !important;
            }
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 flex flex-col h-screen overflow-hidden">

    <!-- Header -->
    <header class="bg-white shadow-md p-4 flex items-center justify-between z-20 flex-shrink-0">
        <div class="flex items-center space-x-4">
            <button id="menu-btn" class="p-2 rounded-md hover:bg-gray-200 transition hidden">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" />
                </svg>
            </button>
            <h1 class="text-xl md:text-2xl font-bold text-gray-800">PDF Editor</h1>
        </div>
        <div id="header-actions" class="flex items-center space-x-2">
            <input type="file" id="file-input" class="hidden" accept="application/pdf" multiple>
            <button id="open-pdf-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg transition duration-300">Open PDF</button>
        </div>
    </header>

    <div class="flex-1 flex overflow-hidden">
        <!-- Drawer Overlay -->
        <div id="drawer-overlay" class="fixed inset-0 bg-black bg-opacity-50 z-30 hidden md:hidden"></div>

        <!-- Drawer/Sidebar -->
        <aside id="sidebar" class="fixed top-0 left-0 h-full w-64 bg-white p-4 overflow-y-auto border-r border-gray-200 z-40">
            <h2 class="text-lg font-semibold mb-4">Actions</h2>
            <div class="space-y-2 mb-6">
                <button id="save-pdf-btn" class="w-full text-left bg-green-500 hover:bg-green-600 text-white font-semibold py-2 px-4 rounded-lg transition disabled:opacity-50 disabled:cursor-not-allowed">Save As...</button>
                <button id="print-pdf-btn" class="w-full text-left bg-gray-500 hover:bg-gray-600 text-white font-semibold py-2 px-4 rounded-lg transition disabled:opacity-50 disabled:cursor-not-allowed">Print</button>
                <button id="close-pdf-btn" class="w-full text-left bg-red-500 hover:bg-red-600 text-white font-semibold py-2 px-4 rounded-lg transition disabled:opacity-50 disabled:cursor-not-allowed">Close</button>
            </div>
            <hr class="my-4">
            <h2 class="text-lg font-semibold mb-4">Tools</h2>
            <div class="space-y-2 mb-6">
                <button id="tool-merge" class="w-full text-left bg-gray-200 hover:bg-gray-300 text-gray-700 font-semibold py-2 px-4 rounded-lg transition disabled:opacity-50 disabled:cursor-not-allowed">Merge Documents</button>
                <button id="tool-split" class="w-full text-left bg-gray-200 hover:bg-gray-300 text-gray-700 font-semibold py-2 px-4 rounded-lg transition disabled:opacity-50 disabled:cursor-not-allowed">Split Document</button>
                <button id="tool-add-text" class="w-full text-left bg-gray-200 hover:bg-gray-300 text-gray-700 font-semibold py-2 px-4 rounded-lg transition disabled:opacity-50 disabled:cursor-not-allowed">Add Text</button>
                <button id="tool-redact" class="w-full text-left bg-gray-200 hover:bg-gray-300 text-gray-700 font-semibold py-2 px-4 rounded-lg transition disabled:opacity-50 disabled:cursor-not-allowed">Redact</button>
            </div>
            <hr class="my-4">
            <h3 class="text-md font-semibold mb-2">Pages (Drag to Sort)</h3>
            <div id="thumbnails-container" class="space-y-2"></div>
        </aside>

        <!-- Main Content -->
        <main id="main-content" class="flex-1 flex flex-col overflow-hidden transition-all duration-300 ease-in-out">
            <div id="viewer-container" class="flex-1 bg-gray-200 p-2 md:p-4 overflow-y-auto">
                <div id="welcome-message" class="h-full flex flex-col items-center justify-center text-center p-4">
                    <svg class="mx-auto h-12 w-12 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true"><path vector-effect="non-scaling-stroke" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" /></svg>
                    <h3 class="mt-2 text-sm font-medium text-gray-900">No PDF selected</h3>
                    <p class="mt-1 text-sm text-gray-500">Get started by opening a PDF file.</p>
                </div>
                <div id="page-container" class="relative w-fit mx-auto"></div>
            </div>
        </main>
    </div>

    <!-- Loader -->
    <div id="loader-overlay" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="loader ease-linear rounded-full border-8 border-t-8 border-gray-200 h-32 w-32"></div>
        <p id="loader-text" class="text-white text-lg ml-4">Loading...</p>
    </div>

    <!-- Secure Redaction Confirmation Modal -->
    <div id="secure-redact-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-md mx-4">
            <h3 class="text-lg font-bold mb-4">Confirm Secure Redaction</h3>
            <p class="text-sm mb-4">This will create a new PDF where the redacted areas are permanently and securely removed.</p>
            <p class="text-sm text-red-600 font-semibold mb-6">Warning: Text on the redacted pages will be converted to an image and will no longer be selectable or searchable. This action cannot be undone.</p>
            <div class="flex justify-end space-x-4">
                <button id="cancel-redact-btn" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-lg hover:bg-gray-300">Cancel</button>
                <button id="confirm-redact-btn" class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700">Proceed</button>
            </div>
        </div>
    </div>
    
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/service-worker.js').catch(err => console.log('SW reg failed: ', err));
            });
        }
    </script>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js`;
            
            const fileInput = document.getElementById('file-input');
            const openPdfBtn = document.getElementById('open-pdf-btn');
            const savePdfBtn = document.getElementById('save-pdf-btn');
            const printPdfBtn = document.getElementById('print-pdf-btn');
            const closePdfBtn = document.getElementById('close-pdf-btn');
            const menuBtn = document.getElementById('menu-btn');
            const sidebar = document.getElementById('sidebar');
            const drawerOverlay = document.getElementById('drawer-overlay');
            const viewerContainer = document.getElementById('viewer-container');
            const pageContainer = document.getElementById('page-container');
            const thumbnailsContainer = document.getElementById('thumbnails-container');
            const welcomeMessage = document.getElementById('welcome-message');
            const loaderOverlay = document.getElementById('loader-overlay');
            const loaderText = document.getElementById('loader-text');
            const toolMergeBtn = document.getElementById('tool-merge');
            const toolSplitBtn = document.getElementById('tool-split');
            const toolAddTextBtn = document.getElementById('tool-add-text');
            const toolRedactBtn = document.getElementById('tool-redact');
            const secureRedactModal = document.getElementById('secure-redact-modal');
            const cancelRedactBtn = document.getElementById('cancel-redact-btn');
            const confirmRedactBtn = document.getElementById('confirm-redact-btn');

            const actionButtons = [savePdfBtn, printPdfBtn, closePdfBtn, toolMergeBtn, toolSplitBtn, toolAddTextBtn, toolRedactBtn];

            let pdfDoc = null, pdfBytes = null, pageOrder = [], activeTool = null, redactionAreas = [];

            const updateActionButtonsState = enabled => actionButtons.forEach(b => b.disabled = !enabled);
            updateActionButtonsState(false);

            const openDrawer = () => { sidebar.classList.add('open'); drawerOverlay.classList.remove('hidden'); };
            const closeDrawer = () => { sidebar.classList.remove('open'); drawerOverlay.classList.add('hidden'); };

            menuBtn.addEventListener('click', e => { e.stopPropagation(); if (pdfDoc) sidebar.classList.contains('open') ? closeDrawer() : openDrawer(); });
            drawerOverlay.addEventListener('click', closeDrawer);

            const closePdf = () => {
                pdfDoc = null; pdfBytes = null; pageOrder = []; redactionAreas = []; activeTool = null;
                pageContainer.innerHTML = ''; thumbnailsContainer.innerHTML = '';
                document.querySelectorAll('.redaction-box').forEach(box => box.remove());
                welcomeMessage.classList.remove('hidden');
                fileInput.value = '';
                updateActionButtonsState(false);
                openPdfBtn.classList.remove('hidden');
                menuBtn.classList.add('hidden');
                closeDrawer();
            };

            const loadPdf = async file => {
                showLoader('Loading PDF...');
                pdfBytes = new Uint8Array(await file.arrayBuffer());
                await loadPdfFromBytes(pdfBytes);
                welcomeMessage.classList.add('hidden');
                openPdfBtn.classList.add('hidden');
                menuBtn.classList.remove('hidden');
                hideLoader();
            };
            
            const loadPdfFromBytes = async bytes => {
                 showLoader('Rendering PDF...');
                 pdfBytes = bytes;
                 pdfDoc = await pdfjsLib.getDocument({ data: bytes }).promise;
                 pageOrder = Array.from({ length: pdfDoc.numPages }, (_, i) => i + 1);
                 await renderAllPages();
                 await renderThumbnails();
                 updateActionButtonsState(true);
                 hideLoader();
            }

            const renderPage = async (pageNum, container) => {
                const page = await pdfDoc.getPage(pageNum);
                const scale = (viewerContainer.clientWidth / page.getViewport({ scale: 1.0 }).width) * 0.95;
                const viewport = page.getViewport({ scale });
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.height = viewport.height; canvas.width = viewport.width;
                canvas.dataset.pageNum = pageNum;
                await page.render({ canvasContext: context, viewport }).promise;
                container.appendChild(canvas);
            };

            const renderAllPages = async () => {
                pageContainer.innerHTML = '';
                for (const pageNum of pageOrder) await renderPage(pageNum, pageContainer);
                viewerContainer.scrollTop = 0;
            };
            
            const renderThumbnails = async () => {
                thumbnailsContainer.innerHTML = '';
                for (let i = 0; i < pageOrder.length; i++) {
                    const pageNum = pageOrder[i];
                    const page = await pdfDoc.getPage(pageNum);
                    const viewport = page.getViewport({ scale: 0.3 });
                    const canvas = document.createElement('canvas');
                    canvas.height = viewport.height; canvas.width = viewport.width;
                    await page.render({ canvasContext: canvas.getContext('2d'), viewport }).promise;
                    const thumbItem = document.createElement('div');
                    thumbItem.className = 'thumbnail-item p-1 rounded-md cursor-pointer relative';
                    thumbItem.dataset.originalIndex = pageNum;
                    const pageNumberLabel = document.createElement('span');
                    pageNumberLabel.textContent = i + 1;
                    pageNumberLabel.className = 'absolute top-1 left-1 bg-blue-500 text-white text-xs font-bold px-1.5 py-0.5 rounded';
                    thumbItem.append(canvas, pageNumberLabel);
                    thumbnailsContainer.appendChild(thumbItem);
                }
            };

            openPdfBtn.addEventListener('click', () => fileInput.click());
            closePdfBtn.addEventListener('click', closePdf);
            fileInput.addEventListener('change', e => { if (e.target.files.length > 0) loadPdf(e.target.files[0]); });

            // --- SAVE LOGIC ---
            savePdfBtn.addEventListener('click', () => {
                if (!pdfDoc) return;
                if (redactionAreas.length > 0) {
                    secureRedactModal.classList.remove('hidden');
                } else {
                    // If no redactions, perform a normal save
                    performStandardSave();
                }
            });

            cancelRedactBtn.addEventListener('click', () => secureRedactModal.classList.add('hidden'));
            confirmRedactBtn.addEventListener('click', () => {
                secureRedactModal.classList.add('hidden');
                performSecureRedaction();
            });

            const performStandardSave = async () => {
                // This is the original, non-secure save for non-redacted files.
                const originalFileName = fileInput.files[0]?.name || 'document.pdf';
                let newFileName = prompt('Enter file name:', `edited-${originalFileName}`);
                if (newFileName === null) return;
                if (newFileName.trim() === '') newFileName = `edited-${originalFileName}`;
                if (!newFileName.toLowerCase().endsWith('.pdf')) newFileName += '.pdf';

                showLoader('Saving PDF...');
                const { PDFDocument } = PDFLib;
                const finalDoc = await PDFDocument.create();
                const originalDoc = await PDFDocument.load(pdfBytes);
                const copiedPages = await finalDoc.copyPages(originalDoc, pageOrder.map(p => p - 1));
                copiedPages.forEach(p => finalDoc.addPage(p));
                const finalPdfBytes = await finalDoc.save();
                downloadBlob(finalPdfBytes, newFileName);
                hideLoader();
            };

            const performSecureRedaction = async () => {
                const originalFileName = fileInput.files[0]?.name || 'document.pdf';
                let newFileName = prompt('Enter file name for the securely redacted PDF:', `redacted-${originalFileName}`);
                if (newFileName === null) return;
                if (newFileName.trim() === '') newFileName = `redacted-${originalFileName}`;
                if (!newFileName.toLowerCase().endsWith('.pdf')) newFileName += '.pdf';

                showLoader('Applying secure redaction...');
                try {
                    const { PDFDocument } = PDFLib;
                    const finalDoc = await PDFDocument.create();
                    const RENDER_SCALE = 2.0; // Higher scale for better quality

                    for (const pageNum of pageOrder) {
                        const page = await pdfDoc.getPage(pageNum);
                        const viewport = page.getViewport({ scale: RENDER_SCALE });
                        const canvas = document.createElement('canvas');
                        const context = canvas.getContext('2d');
                        canvas.height = viewport.height; canvas.width = viewport.width;
                        
                        await page.render({ canvasContext: context, viewport }).promise;

                        const pageRedactions = redactionAreas.filter(r => r.originalPageNum === pageNum);
                        if (pageRedactions.length > 0) {
                            context.fillStyle = 'white';
                            for (const area of pageRedactions) {
                                // Convert PDF coordinates to canvas coordinates for drawing
                                const rectX = area.x * RENDER_SCALE;
                                const rectWidth = area.width * RENDER_SCALE;
                                const rectHeight = area.height * RENDER_SCALE;
                                const rectY = viewport.height - (area.y * RENDER_SCALE) - rectHeight;
                                context.fillRect(rectX, rectY, rectWidth, rectHeight);
                            }
                        }

                        const pngImageBytes = await new Promise(resolve => canvas.toBlob(blob => {
                            const reader = new FileReader();
                            reader.onload = () => resolve(new Uint8Array(reader.result));
                            reader.readAsArrayBuffer(blob);
                        }, 'image/png'));
                        
                        const pngImage = await finalDoc.embedPng(pngImageBytes);
                        const { width, height } = page.getViewport({ scale: 1.0 });
                        const newPage = finalDoc.addPage([width, height]);
                        newPage.drawImage(pngImage, { x: 0, y: 0, width: newPage.getWidth(), height: newPage.getHeight() });
                    }
                    const finalPdfBytes = await finalDoc.save();
                    downloadBlob(finalPdfBytes, newFileName);
                } catch (error) {
                    console.error("Error during secure redaction:", error);
                    alert("An error occurred while applying secure redaction.");
                } finally {
                    hideLoader();
                }
            };

            // --- TOOLS & INTERACTION LOGIC ---
            let interactionStartX, interactionStartY, redactionBox = null;

            const handleInteractionStart = e => {
                if (!activeTool || !e.target.matches('canvas')) return;
                e.preventDefault();
                const touch = e.changedTouches ? e.changedTouches[0] : e;
                interactionStartX = touch.clientX; interactionStartY = touch.clientY;
                if (activeTool === 'redact') {
                    redactionBox = document.createElement('div');
                    redactionBox.className = 'redaction-box';
                    pageContainer.appendChild(redactionBox);
                    updateRedactionBox(e);
                }
            };

            const handleInteractionMove = e => {
                if (!activeTool || !e.target.matches('canvas') || !redactionBox) return;
                e.preventDefault();
                updateRedactionBox(e);
            };

            const handleInteractionEnd = async e => {
                if (!activeTool || !e.target.matches('canvas')) return;
                e.preventDefault();
                const canvas = e.target;
                const rect = canvas.getBoundingClientRect();
                const originalPageNum = parseInt(canvas.dataset.pageNum);
                const page = await pdfDoc.getPage(originalPageNum);
                const scale = (viewerContainer.clientWidth / page.getViewport({ scale: 1.0 }).width) * 0.95;
                const viewport = page.getViewport({ scale });
                
                if (activeTool === 'redact' && redactionBox) {
                    const boxRect = redactionBox.getBoundingClientRect();
                    const [left, top] = viewport.convertToPdfPoint(boxRect.left - rect.left, boxRect.top - rect.top);
                    const [right, bottom] = viewport.convertToPdfPoint(boxRect.right - rect.left, boxRect.bottom - rect.top);
                    if ((right - left) > 0 && (top - bottom) > 0) {
                        redactionAreas.push({ originalPageNum, x: left, y: bottom, width: right - left, height: top - bottom });
                    }
                    redactionBox = null; // Don't remove the visual box, just the reference
                }
                resetTool();
            };
            
            const updateRedactionBox = e => {
                if (!redactionBox) return;
                const touch = e.changedTouches ? e.changedTouches[0] : e;
                const rect = e.target.getBoundingClientRect();
                const left = Math.min(interactionStartX, touch.clientX) - rect.left;
                const top = Math.min(interactionStartY, touch.clientY) - rect.top;
                const width = Math.abs(touch.clientX - interactionStartX);
                const height = Math.abs(touch.clientY - interactionStartY);
                redactionBox.style.left = `${left}px`;
                redactionBox.style.top = `${top}px`;
                redactionBox.style.width = `${width}px`;
                redactionBox.style.height = `${height}px`;
            };

            pageContainer.addEventListener('mousedown', handleInteractionStart);
            pageContainer.addEventListener('mousemove', handleInteractionMove);
            pageContainer.addEventListener('mouseup', handleInteractionEnd);
            pageContainer.addEventListener('touchstart', handleInteractionStart, { passive: false });
            pageContainer.addEventListener('touchmove', handleInteractionMove, { passive: false });
            pageContainer.addEventListener('touchend', handleInteractionEnd);
            
            const resetTool = () => { activeTool = null; pageContainer.style.cursor = 'default'; };
            const activateTool = (toolName, message) => { activeTool = toolName; alert(message); closeDrawer(); return true; };
            toolRedactBtn.addEventListener('click', () => { if (activateTool('redact', 'Tap and drag on a page to create a redaction area.')) { /* Intentionally left blank */ } });

            // --- UTILITY FUNCTIONS ---
            const showLoader = text => { loaderText.textContent = text; loaderOverlay.classList.remove('hidden'); };
            const hideLoader = () => loaderOverlay.classList.add('hidden');
            const downloadBlob = (data, fileName) => {
                const blob = new Blob([data], { type: 'application/pdf' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none'; a.href = url; a.download = fileName;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);
            };
        });
    </script>
</body>
</html>
