<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Offline PDF Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .loader { border-top-color: #3498db; -webkit-animation: spin 1s linear infinite; animation: spin 1s linear infinite; }
        @-webkit-keyframes spin { 0% { -webkit-transform: rotate(0deg); } 100% { -webkit-transform: rotate(360deg); } }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        #page-container canvas { 
            box-shadow: 0 4px 12px rgba(0,0,0,0.15); 
            margin-bottom: 1rem; 
            max-width: 100%;
            height: auto;
        }

        .thumbnail-item { border: 2px solid transparent; transition: border-color 0.2s; }
        .thumbnail-item.selected { border-color: #3b82f6; }
        .sortable-ghost { opacity: 0.4; background: #c7d2fe; }
        
        .redaction-box, .text-box {
            position: absolute;
            border: 2px dashed #333;
            cursor: move;
            z-index: 10;
        }
        .redaction-box { background-color: rgba(255, 255, 255, 0.8); }
        .text-box { background-color: rgba(59, 130, 246, 0.1); }

        .redaction-box.selected, .text-box.selected {
            border: 2px solid #3b82f6;
            z-index: 11;
        }
        
        .text-box textarea {
            width: 100%;
            height: 100%;
            background: transparent;
            border: none;
            outline: none;
            resize: none;
            padding: 2px;
            margin: 0;
            font-family: inherit;
            line-height: 1.2;
            color: black;
            /* Key styles for auto-sizing */
            white-space: pre;
            overflow: hidden;
        }

        .resize-handle {
            position: absolute;
            width: 24px;
            height: 24px;
            background-color: #3b82f6;
            border: 2px solid white;
            border-radius: 50%;
            z-index: 12;
            display: none;
        }
        .redaction-box.resize-mode .resize-handle { display: block; }
        .resize-handle.nw { top: -12px; left: -12px; cursor: nwse-resize; }
        .resize-handle.ne { top: -12px; right: -12px; cursor: nesw-resize; }
        .resize-handle.sw { bottom: -12px; left: -12px; cursor: nesw-resize; }
        .resize-handle.se { bottom: -12px; right: -12px; cursor: nwse-resize; }
        
        #sidebar { transform: translateX(-100%); transition: transform 0.3s ease-in-out; }
        #sidebar.open { transform: translateX(0); }

        #redaction-toolbar, #text-toolbar {
            transition: transform 0.3s ease-in-out;
            transform: translateY(100%);
        }
        #redaction-toolbar.visible, #text-toolbar.visible { transform: translateY(0); }

        @media (min-width: 768px) {
            #sidebar { transform: translateX(0); }
            #main-content { margin-left: 16rem; }
            #menu-btn { display: none; }
            #drawer-overlay { display: none !important; }
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 flex flex-col h-screen overflow-hidden">

    <!-- Main container -->
    <div class="flex-1 flex flex-col overflow-hidden relative">
        <!-- Header -->
        <header class="bg-white shadow-md p-4 flex items-center justify-between z-20 flex-shrink-0">
            <div class="flex items-center space-x-4">
                <button id="menu-btn" class="p-2 rounded-md hover:bg-gray-200 transition hidden">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" /></svg>
                </button>
                <h1 class="text-xl md:text-2xl font-bold text-gray-800">PDF Editor</h1>
            </div>
            <div id="header-actions" class="flex items-center space-x-2">
                <input type="file" id="file-input" class="hidden" accept="application/pdf" multiple>
                <button id="open-pdf-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg transition duration-300">Open PDF</button>
            </div>
        </header>

        <div class="flex-1 flex overflow-hidden">
            <!-- Drawer Overlay -->
            <div id="drawer-overlay" class="fixed inset-0 bg-black bg-opacity-50 z-30 hidden md:hidden"></div>

            <!-- Drawer/Sidebar -->
            <aside id="sidebar" class="fixed top-0 left-0 h-full w-64 bg-white p-4 overflow-y-auto border-r border-gray-200 z-40">
                <h2 class="text-lg font-semibold mb-4">Actions</h2>
                <div class="space-y-2 mb-6">
                    <button id="save-pdf-btn" class="w-full text-left bg-green-500 hover:bg-green-600 text-white font-semibold py-2 px-4 rounded-lg transition disabled:opacity-50 disabled:cursor-not-allowed">Save As...</button>
                    <button id="print-pdf-btn" class="w-full text-left bg-gray-500 hover:bg-gray-600 text-white font-semibold py-2 px-4 rounded-lg transition disabled:opacity-50 disabled:cursor-not-allowed">Print</button>
                    <button id="close-pdf-btn" class="w-full text-left bg-red-500 hover:bg-red-600 text-white font-semibold py-2 px-4 rounded-lg transition disabled:opacity-50 disabled:cursor-not-allowed">Close</button>
                </div>
                <hr class="my-4">
                <h2 class="text-lg font-semibold mb-4">Tools</h2>
                <div class="space-y-2 mb-6">
                    <button id="tool-merge" class="w-full text-left bg-gray-200 hover:bg-gray-300 text-gray-700 font-semibold py-2 px-4 rounded-lg transition disabled:opacity-50 disabled:cursor-not-allowed">Merge Documents</button>
                    <button id="tool-split" class="w-full text-left bg-gray-200 hover:bg-gray-300 text-gray-700 font-semibold py-2 px-4 rounded-lg transition disabled:opacity-50 disabled:cursor-not-allowed">Split Document</button>
                    <button id="tool-add-text" class="w-full text-left bg-gray-200 hover:bg-gray-300 text-gray-700 font-semibold py-2 px-4 rounded-lg transition disabled:opacity-50 disabled:cursor-not-allowed">Add Text</button>
                    <button id="tool-redact" class="w-full text-left bg-gray-200 hover:bg-gray-300 text-gray-700 font-semibold py-2 px-4 rounded-lg transition disabled:opacity-50 disabled:cursor-not-allowed">Redact</button>
                </div>
                <hr class="my-4">
                <h3 class="text-md font-semibold mb-2">Pages (Drag to Sort)</h3>
                <div id="thumbnails-container" class="space-y-2"></div>
            </aside>

            <!-- Main Content -->
            <main id="main-content" class="flex-1 flex flex-col overflow-hidden transition-all duration-300 ease-in-out">
                <div id="viewer-container" class="flex-1 bg-gray-200 p-2 md:p-4 overflow-y-auto">
                    <div id="welcome-message" class="h-full flex flex-col items-center justify-center text-center p-4">
                        <svg class="mx-auto h-12 w-12 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true"><path vector-effect="non-scaling-stroke" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" /></svg>
                        <h3 class="mt-2 text-sm font-medium text-gray-900">No PDF selected</h3>
                        <p class="mt-1 text-sm text-gray-500">Get started by opening a PDF file.</p>
                    </div>
                    <div id="page-container" class="relative w-fit mx-auto"></div>
                </div>
            </main>
        </div>

        <!-- Redaction Contextual Toolbar -->
        <div id="redaction-toolbar" class="fixed bottom-0 left-0 right-0 bg-gray-800 text-white p-2 flex justify-center items-center space-x-4 z-40">
            <button id="toolbar-resize-btn" class="p-2 rounded-md hover:bg-gray-700" title="Resize">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 1v4m0 0h-4m4 0l-5-5" /></svg>
            </button>
            <button id="toolbar-delete-btn" class="p-2 rounded-md hover:bg-gray-700" title="Delete">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>
            </button>
        </div>
        
        <!-- Text Editing Contextual Toolbar -->
        <div id="text-toolbar" class="fixed bottom-0 left-0 right-0 bg-gray-800 text-white p-2 flex justify-center items-center space-x-4 z-40">
            <label for="text-font-size" class="text-sm">Size:</label>
            <input type="number" id="text-font-size" class="bg-gray-700 text-white rounded-md p-1 w-16 text-center" value="12" min="1">
            <label for="text-color" class="text-sm">Color:</label>
            <input type="color" id="text-color" class="bg-gray-700 rounded-md" value="#000000">
            <button id="text-toolbar-delete-btn" class="p-2 rounded-md hover:bg-gray-700" title="Delete Textbox">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>
            </button>
        </div>
    </div>


    <!-- Loader -->
    <div id="loader-overlay" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="loader ease-linear rounded-full border-8 border-t-8 border-gray-200 h-32 w-32"></div>
        <p id="loader-text" class="text-white text-lg ml-4">Loading...</p>
    </div>

    <!-- Secure Redaction Confirmation Modal -->
    <div id="secure-redact-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-md mx-4">
            <h3 class="text-lg font-bold mb-4">Confirm Secure Redaction</h3>
            <p class="text-sm mb-4">This will create a new PDF where the redacted areas are permanently and securely removed.</p>
            <p class="text-sm text-red-600 font-semibold mb-6">Warning: Text on the redacted pages will be converted to an image and will no longer be selectable or searchable. This action cannot be undone.</p>
            <div class="flex justify-end space-x-4">
                <button id="cancel-redact-btn" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-lg hover:bg-gray-300">Cancel</button>
                <button id="confirm-redact-btn" class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700">Proceed</button>
            </div>
        </div>
    </div>
    
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/service-worker.js').catch(err => console.log('SW reg failed: ', err));
            });
        }
    </script>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js`;
            
            // --- DOM Element References ---
            const fileInput = document.getElementById('file-input');
            const openPdfBtn = document.getElementById('open-pdf-btn');
            const savePdfBtn = document.getElementById('save-pdf-btn');
            const printPdfBtn = document.getElementById('print-pdf-btn');
            const closePdfBtn = document.getElementById('close-pdf-btn');
            const menuBtn = document.getElementById('menu-btn');
            const sidebar = document.getElementById('sidebar');
            const drawerOverlay = document.getElementById('drawer-overlay');
            const viewerContainer = document.getElementById('viewer-container');
            const pageContainer = document.getElementById('page-container');
            const thumbnailsContainer = document.getElementById('thumbnails-container');
            const welcomeMessage = document.getElementById('welcome-message');
            const loaderOverlay = document.getElementById('loader-overlay');
            const loaderText = document.getElementById('loader-text');
            const toolAddTextBtn = document.getElementById('tool-add-text');
            const toolRedactBtn = document.getElementById('tool-redact');
            const secureRedactModal = document.getElementById('secure-redact-modal');
            const cancelRedactBtn = document.getElementById('cancel-redact-btn');
            const confirmRedactBtn = document.getElementById('confirm-redact-btn');
            
            // Redaction Toolbar
            const redactionToolbar = document.getElementById('redaction-toolbar');
            const toolbarResizeBtn = document.getElementById('toolbar-resize-btn');
            const toolbarDeleteBtn = document.getElementById('toolbar-delete-btn');

            // Text Toolbar
            const textToolbar = document.getElementById('text-toolbar');
            const textFontSizeInput = document.getElementById('text-font-size');
            const textColorInput = document.getElementById('text-color');
            const textToolbarDeleteBtn = document.getElementById('text-toolbar-delete-btn');

            const actionButtons = [savePdfBtn, printPdfBtn, closePdfBtn, document.getElementById('tool-merge'), document.getElementById('tool-split'), toolAddTextBtn, toolRedactBtn];

            // --- State Variables ---
            let pdfDoc = null, pdfBytes = null, pageOrder = [], activeTool = null;
            let redactionAreas = [], textObjects = [];
            let selectedRedactionBox = null, selectedTextBox = null;

            // --- Core App Logic ---
            const updateActionButtonsState = enabled => actionButtons.forEach(b => b.disabled = !enabled);
            updateActionButtonsState(false);

            const openDrawer = () => { sidebar.classList.add('open'); drawerOverlay.classList.remove('hidden'); };
            const closeDrawer = () => { sidebar.classList.remove('open'); drawerOverlay.classList.add('hidden'); };

            menuBtn.addEventListener('click', e => { e.stopPropagation(); if (pdfDoc) sidebar.classList.contains('open') ? closeDrawer() : openDrawer(); });
            drawerOverlay.addEventListener('click', closeDrawer);

            const closePdf = () => {
                pdfDoc = null; pdfBytes = null; pageOrder = []; redactionAreas = []; textObjects = []; activeTool = null;
                pageContainer.innerHTML = ''; thumbnailsContainer.innerHTML = '';
                welcomeMessage.classList.remove('hidden');
                fileInput.value = '';
                updateActionButtonsState(false);
                openPdfBtn.classList.remove('hidden');
                menuBtn.classList.add('hidden');
                closeDrawer();
                selectRedactionBox(null);
                selectTextBox(null);
            };

            const loadPdf = async file => {
                showLoader('Loading PDF...');
                pdfBytes = new Uint8Array(await file.arrayBuffer());
                await loadPdfFromBytes(pdfBytes);
                welcomeMessage.classList.add('hidden');
                openPdfBtn.classList.add('hidden');
                menuBtn.classList.remove('hidden');
                hideLoader();
            };
            
            const loadPdfFromBytes = async bytes => {
                 showLoader('Rendering PDF...');
                 pdfBytes = bytes;
                 pdfDoc = await pdfjsLib.getDocument({ data: bytes }).promise;
                 pageOrder = Array.from({ length: pdfDoc.numPages }, (_, i) => i + 1);
                 await renderAllPages();
                 await renderThumbnails();
                 updateActionButtonsState(true);
                 hideLoader();
            }

            const renderAllPages = async () => {
                pageContainer.innerHTML = '';
                for (const pageNum of pageOrder) {
                    const page = await pdfDoc.getPage(pageNum);
                    const scale = (viewerContainer.clientWidth / page.getViewport({ scale: 1.0 }).width) * 0.95;
                    const viewport = page.getViewport({ scale });
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.height = viewport.height; canvas.width = viewport.width;
                    canvas.dataset.pageNum = pageNum;
                    await page.render({ canvasContext: context, viewport }).promise;
                    
                    const pageDiv = document.createElement('div');
                    pageDiv.className = 'relative';
                    pageDiv.appendChild(canvas);
                    pageContainer.appendChild(pageDiv);
                }
                await renderRedactionBoxes();
                await renderTextObjects();
                viewerContainer.scrollTop = 0;
            };
            
            const renderThumbnails = async () => {
                thumbnailsContainer.innerHTML = '';
                for (let i = 0; i < pageOrder.length; i++) {
                    const pageNum = pageOrder[i];
                    const page = await pdfDoc.getPage(pageNum);
                    const viewport = page.getViewport({ scale: 0.3 });
                    const canvas = document.createElement('canvas');
                    canvas.height = viewport.height; canvas.width = viewport.width;
                    await page.render({ canvasContext: canvas.getContext('2d'), viewport }).promise;
                    const thumbItem = document.createElement('div');
                    thumbItem.className = 'thumbnail-item p-1 rounded-md cursor-pointer relative';
                    thumbItem.dataset.originalIndex = pageNum;
                    const pageNumberLabel = document.createElement('span');
                    pageNumberLabel.textContent = i + 1;
                    pageNumberLabel.className = 'absolute top-1 left-1 bg-blue-500 text-white text-xs font-bold px-1.5 py-0.5 rounded';
                    thumbItem.append(canvas, pageNumberLabel);
                    thumbnailsContainer.appendChild(thumbItem);
                }
            };

            openPdfBtn.addEventListener('click', () => fileInput.click());
            closePdfBtn.addEventListener('click', closePdf);
            fileInput.addEventListener('change', e => { if (e.target.files.length > 0) loadPdf(e.target.files[0]); });

            savePdfBtn.addEventListener('click', () => {
                if (!pdfDoc) return;
                if (redactionAreas.length > 0) {
                    secureRedactModal.classList.remove('hidden');
                } else {
                    performStandardSave();
                }
            });

            cancelRedactBtn.addEventListener('click', () => secureRedactModal.classList.add('hidden'));
            confirmRedactBtn.addEventListener('click', () => {
                secureRedactModal.classList.add('hidden');
                performSecureRedaction();
            });

            const performStandardSave = async () => {
                const originalFileName = fileInput.files[0]?.name || 'document.pdf';
                let newFileName = prompt('Enter file name:', `edited-${originalFileName}`);
                if (newFileName === null) return;
                if (newFileName.trim() === '') newFileName = `edited-${originalFileName}`;
                if (!newFileName.toLowerCase().endsWith('.pdf')) newFileName += '.pdf';

                showLoader('Saving PDF...');
                const { PDFDocument, rgb, StandardFonts } = PDFLib;
                const finalDoc = await PDFDocument.load(pdfBytes);
                const helveticaFont = await finalDoc.embedFont(StandardFonts.Helvetica);

                // Apply text objects
                for (const textObj of textObjects) {
                    const pageIndex = pageOrder.indexOf(textObj.originalPageNum);
                    if (pageIndex === -1) continue;
                    const page = finalDoc.getPage(pageIndex);
                    const { height } = page.getSize();
                    const color = hexToRgb(textObj.color);
                    page.drawText(textObj.text, {
                        x: textObj.x,
                        y: height - textObj.y - textObj.fontSize, // Adjust y-coord from top-left to bottom-left
                        font: helveticaFont,
                        size: textObj.fontSize,
                        color: rgb(color.r / 255, color.g / 255, color.b / 255),
                        lineHeight: textObj.fontSize * 1.2,
                    });
                }
                
                // Reorder pages if necessary
                const finalPdfBytes = await finalDoc.save();
                const reorderedDoc = await PDFDocument.load(finalPdfBytes);
                const finalFinalDoc = await PDFDocument.create();
                const pageIndices = pageOrder.map(pNum => reorderedDoc.getPageCount() > (pNum-1) ? (pNum-1) : -1).filter(i => i !== -1);
                const copiedPages = await finalFinalDoc.copyPages(reorderedDoc, pageIndices);
                copiedPages.forEach(p => finalFinalDoc.addPage(p));


                const finalFinalPdfBytes = await finalFinalDoc.save();
                downloadBlob(finalFinalPdfBytes, newFileName);
                hideLoader();
            };

            const performSecureRedaction = async () => {
                // This will save redactions and text.
                alert("Secure redaction will flatten text and redactions into the page image.");
                 showLoader('Applying secure redaction...');
                try {
                    const { PDFDocument } = PDFLib;
                    const finalDoc = await PDFDocument.create();
                    const RENDER_SCALE = 2.0;

                    for (const pageNum of pageOrder) {
                        const page = await pdfDoc.getPage(pageNum);
                        const viewport = page.getViewport({ scale: RENDER_SCALE });
                        const canvas = document.createElement('canvas');
                        const context = canvas.getContext('2d');
                        canvas.height = viewport.height; canvas.width = viewport.width;
                        
                        await page.render({ canvasContext: context, viewport }).promise;

                        // Draw text objects onto canvas
                        const pageTextObjects = textObjects.filter(t => t.originalPageNum === pageNum);
                        for (const textObj of pageTextObjects) {
                            context.font = `${textObj.fontSize * RENDER_SCALE}px Helvetica`;
                            context.fillStyle = textObj.color;
                            // Handle multiline text
                            const lines = textObj.text.split('\n');
                            for (let i = 0; i < lines.length; i++) {
                                context.fillText(lines[i], textObj.x * RENDER_SCALE, (textObj.y * RENDER_SCALE) + (i * textObj.fontSize * RENDER_SCALE * 1.2));
                            }
                        }

                        // Draw redaction boxes
                        const pageRedactions = redactionAreas.filter(r => r.originalPageNum === pageNum);
                        if (pageRedactions.length > 0) {
                            context.fillStyle = 'white';
                            for (const area of pageRedactions) {
                                const rectX = area.x * RENDER_SCALE;
                                const rectWidth = area.width * RENDER_SCALE;
                                const rectHeight = area.height * RENDER_SCALE;
                                const rectY = area.y * RENDER_SCALE;
                                context.fillRect(rectX, rectY, rectWidth, rectHeight);
                            }
                        }

                        const pngImageBytes = await new Promise(resolve => canvas.toBlob(blob => {
                            const reader = new FileReader();
                            reader.onload = () => resolve(new Uint8Array(reader.result));
                            reader.readAsArrayBuffer(blob);
                        }, 'image/png'));
                        
                        const pngImage = await finalDoc.embedPng(pngImageBytes);
                        const { width, height } = page.getViewport({ scale: 1.0 });
                        const newPage = finalDoc.addPage([width, height]);
                        newPage.drawImage(pngImage, { x: 0, y: 0, width: newPage.getWidth(), height: newPage.getHeight() });
                    }
                    const finalPdfBytes = await finalDoc.save();
                    const originalFileName = fileInput.files[0]?.name || 'document.pdf';
                    downloadBlob(finalPdfBytes, `redacted-${originalFileName}`);
                } catch (error) {
                    console.error("Error during secure redaction:", error);
                    alert("An error occurred while applying secure redaction.");
                } finally {
                    hideLoader();
                }
            };
            
            // --- OBJECT RENDERING & SELECTION ---

            const renderRedactionBoxes = async () => {
                document.querySelectorAll('.redaction-box').forEach(box => box.remove());
                for (const [index, area] of redactionAreas.entries()) {
                    const pageDiv = pageContainer.querySelector(`canvas[data-page-num="${area.originalPageNum}"]`)?.parentElement;
                    if (!pageDiv) continue;
                    const canvas = pageDiv.querySelector('canvas');
                    const page = await pdfDoc.getPage(area.originalPageNum);
                    const scale = canvas.width / page.getViewport({scale: 1.0}).width;
                    const box = document.createElement('div');
                    box.className = 'redaction-box';
                    box.dataset.redactionIndex = index;
                    box.style.left = `${area.x * scale}px`;
                    box.style.top = `${area.y * scale}px`;
                    box.style.width = `${area.width * scale}px`;
                    box.style.height = `${area.height * scale}px`;
                    pageDiv.appendChild(box);
                }
            };
            
            async function autoSizeTextBox(textarea) {
                if (!textarea || !textarea.parentElement) return;

                const textIndex = parseInt(textarea.parentElement.dataset.textIndex);
                if (isNaN(textIndex) || !textObjects[textIndex]) return;

                const textObj = textObjects[textIndex];
                const canvas = textarea.closest('.relative')?.querySelector('canvas');
                if (!canvas) return;

                const page = await pdfDoc.getPage(textObj.originalPageNum);
                const scale = canvas.width / page.getViewport({ scale: 1.0 }).width;

                // Temporarily apply styles to measure content
                textarea.style.width = 'auto';
                textarea.style.height = 'auto';

                const newWidthPx = textarea.scrollWidth;
                const newHeightPx = textarea.scrollHeight;

                // Apply new size to textarea and its container
                textarea.style.width = `${newWidthPx}px`;
                textarea.style.height = `${newHeightPx}px`;
                textarea.parentElement.style.width = `${newWidthPx}px`;
                textarea.parentElement.style.height = `${newHeightPx}px`;

                // Update data model with PDF units
                textObj.width = newWidthPx / scale;
                textObj.height = newHeightPx / scale;
            }

            const renderTextObjects = async () => {
                document.querySelectorAll('.text-box').forEach(box => box.remove());
                for (const [index, textObj] of textObjects.entries()) {
                    const pageDiv = pageContainer.querySelector(`canvas[data-page-num="${textObj.originalPageNum}"]`)?.parentElement;
                    if (!pageDiv) continue;
                    const canvas = pageDiv.querySelector('canvas');
                    const page = await pdfDoc.getPage(textObj.originalPageNum);
                    const scale = canvas.width / page.getViewport({scale: 1.0}).width;
                    
                    const box = document.createElement('div');
                    box.className = 'text-box';
                    box.dataset.textIndex = index;
                    box.style.left = `${textObj.x * scale}px`;
                    box.style.top = `${textObj.y * scale}px`;
                    
                    const textarea = document.createElement('textarea');
                    textarea.value = textObj.text;
                    textarea.style.fontSize = `${textObj.fontSize * scale}px`;
                    textarea.style.color = textObj.color;
                    
                    textarea.addEventListener('input', () => {
                        textObjects[index].text = textarea.value;
                        autoSizeTextBox(textarea);
                    });
                    
                    box.appendChild(textarea);
                    pageDiv.appendChild(box);
                    
                    // Set initial size after rendering
                    await Promise.resolve(); // Wait for element to be in DOM
                    autoSizeTextBox(textarea);
                }
            };

            const selectRedactionBox = (boxElement, internalCall = false) => {
                if (selectedRedactionBox) {
                    selectedRedactionBox.classList.remove('selected', 'resize-mode');
                    Array.from(selectedRedactionBox.children).forEach(child => child.remove());
                }
                if (!internalCall) selectTextBox(null, true); // Prevent recursion
                
                if (boxElement) {
                    selectedRedactionBox = boxElement;
                    selectedRedactionBox.classList.add('selected');
                    redactionToolbar.classList.add('visible');
                } else {
                    selectedRedactionBox = null;
                    redactionToolbar.classList.remove('visible');
                }
            };

            const selectTextBox = (boxElement, internalCall = false) => {
                if (selectedTextBox) selectedTextBox.classList.remove('selected');
                if (!internalCall) selectRedactionBox(null, true); // Prevent recursion

                if (boxElement) {
                    selectedTextBox = boxElement;
                    selectedTextBox.classList.add('selected');
                    const textObj = textObjects[parseInt(boxElement.dataset.textIndex)];
                    textFontSizeInput.value = textObj.fontSize;
                    textColorInput.value = textObj.color;
                    textToolbar.classList.add('visible');
                    boxElement.querySelector('textarea').focus();
                } else {
                    selectedTextBox = null;
                    textToolbar.classList.remove('visible');
                }
            };

            // --- TOOLBAR EVENT LISTENERS ---
            toolbarResizeBtn.addEventListener('click', () => {
                if (!selectedRedactionBox) return;
                selectedRedactionBox.classList.toggle('resize-mode');
                if (selectedRedactionBox.classList.contains('resize-mode')) {
                     ['nw', 'ne', 'sw', 'se'].forEach(pos => {
                        const handle = document.createElement('div');
                        handle.className = `resize-handle ${pos}`;
                        selectedRedactionBox.appendChild(handle);
                    });
                } else {
                    Array.from(selectedRedactionBox.children).forEach(child => child.remove());
                }
            });

            toolbarDeleteBtn.addEventListener('click', async () => {
                if (!selectedRedactionBox) return;
                const index = parseInt(selectedRedactionBox.dataset.redactionIndex);
                redactionAreas.splice(index, 1);
                selectRedactionBox(null);
                await renderRedactionBoxes();
            });

            textFontSizeInput.addEventListener('input', async () => {
                if (!selectedTextBox) return;
                const index = parseInt(selectedTextBox.dataset.textIndex);
                const newSize = parseInt(textFontSizeInput.value);
                textObjects[index].fontSize = newSize;
                const textarea = selectedTextBox.querySelector('textarea');
                const canvas = selectedTextBox.closest('.relative').querySelector('canvas');
                const page = await pdfDoc.getPage(textObjects[index].originalPageNum);
                const scale = canvas.width / page.getViewport({scale: 1.0}).width;
                textarea.style.fontSize = `${newSize * scale}px`;
                autoSizeTextBox(textarea);
            });

            textColorInput.addEventListener('input', () => {
                if (!selectedTextBox) return;
                const index = parseInt(selectedTextBox.dataset.textIndex);
                const newColor = textColorInput.value;
                textObjects[index].color = newColor;
                selectedTextBox.querySelector('textarea').style.color = newColor;
            });

            textToolbarDeleteBtn.addEventListener('click', async () => {
                if (!selectedTextBox) return;
                const index = parseInt(selectedTextBox.dataset.textIndex);
                textObjects.splice(index, 1);
                selectTextBox(null);
                await renderTextObjects();
            });


            // --- INTERACTION LOGIC ---
            let interactionState = { type: null, startX: 0, startY: 0, startLeft: 0, startTop: 0, startWidth: 0, startHeight: 0, handle: null };

            pageContainer.addEventListener('mousedown', handleInteractionStart);
            document.addEventListener('mousemove', handleInteractionMove);
            document.addEventListener('mouseup', handleInteractionEnd);
            pageContainer.addEventListener('touchstart', handleInteractionStart, { passive: false });
            document.addEventListener('touchmove', handleInteractionMove, { passive: false });
            document.addEventListener('touchend', handleInteractionEnd);
            
            async function handleInteractionStart(e) {
                const touch = e.changedTouches ? e.changedTouches[0] : e;
                const target = e.target;

                if (target.closest('.resize-handle')) {
                    e.stopPropagation();
                    interactionState.type = 'resize';
                    interactionState.handle = target.closest('.resize-handle').classList[1];
                } else if (target.closest('.redaction-box')) {
                    e.stopPropagation();
                    interactionState.type = 'move';
                    selectRedactionBox(target.closest('.redaction-box'));
                } else if (target.closest('.text-box')) {
                    e.stopPropagation();
                    interactionState.type = 'move';
                    selectTextBox(target.closest('.text-box'));
                } else if (target.matches('canvas')) {
                    if (activeTool === 'redact') {
                        interactionState.type = 'create-redaction';
                        selectRedactionBox(null);
                    } else if (activeTool === 'add-text') {
                        interactionState.type = 'create-text';
                        selectTextBox(null);
                    } else {
                        interactionState.type = null;
                        selectRedactionBox(null);
                        selectTextBox(null);
                    }
                } else {
                    if (!target.closest('#redaction-toolbar') && !target.closest('#text-toolbar')) {
                       selectRedactionBox(null);
                       selectTextBox(null);
                    }
                    interactionState.type = null;
                    return;
                }

                interactionState.startX = touch.clientX;
                interactionState.startY = touch.clientY;
                const selectedBox = selectedRedactionBox || selectedTextBox;
                if (selectedBox) {
                    interactionState.startLeft = selectedBox.offsetLeft;
                    interactionState.startTop = selectedBox.offsetTop;
                    interactionState.startWidth = selectedBox.offsetWidth;
                    interactionState.startHeight = selectedBox.offsetHeight;
                }
            }

            function handleInteractionMove(e) {
                if (!interactionState.type || interactionState.type.startsWith('create')) return;
                e.preventDefault();
                const touch = e.changedTouches ? e.changedTouches[0] : e;
                const dx = touch.clientX - interactionState.startX;
                const dy = touch.clientY - interactionState.startY;
                const selectedBox = selectedRedactionBox || selectedTextBox;
                if (!selectedBox) return;

                if (interactionState.type === 'move') {
                    selectedBox.style.left = `${interactionState.startLeft + dx}px`;
                    selectedBox.style.top = `${interactionState.startTop + dy}px`;
                } else if (interactionState.type === 'resize') {
                    const { handle, startLeft, startTop, startWidth, startHeight } = interactionState;
                    if (handle.includes('e')) selectedBox.style.width = `${startWidth + dx}px`;
                    if (handle.includes('w')) {
                        selectedBox.style.width = `${startWidth - dx}px`;
                        selectedBox.style.left = `${startLeft + dx}px`;
                    }
                    if (handle.includes('s')) selectedBox.style.height = `${startHeight + dy}px`;
                    if (handle.includes('n')) {
                        selectedBox.style.height = `${startHeight - dy}px`;
                        selectedBox.style.top = `${startTop + dy}px`;
                    }
                }
            }
            
            async function handleInteractionEnd(e) {
                if (!interactionState.type) return;
                
                const selectedBox = selectedRedactionBox || selectedTextBox;
                const canvas = selectedBox ? selectedBox.closest('.relative').querySelector('canvas') : e.target.closest('canvas');
                if (!canvas) {
                    interactionState.type = null;
                    return;
                }
                
                const pageNum = parseInt(canvas.dataset.pageNum);
                const page = await pdfDoc.getPage(pageNum);
                const scale = canvas.width / page.getViewport({scale: 1.0}).width;
                const canvasRect = canvas.getBoundingClientRect();

                if (interactionState.type === 'move' || interactionState.type === 'resize') {
                    const rect = selectedBox.getBoundingClientRect();
                    const x = (rect.left - canvasRect.left) / scale;
                    const y = (rect.top - canvasRect.top) / scale;
                    const width = rect.width / scale;
                    const height = rect.height / scale;

                    if (selectedRedactionBox) {
                        const index = parseInt(selectedRedactionBox.dataset.redactionIndex);
                        redactionAreas[index] = { ...redactionAreas[index], x, y, width, height };
                    } else if (selectedTextBox) {
                        const index = parseInt(selectedTextBox.dataset.textIndex);
                        textObjects[index] = { ...textObjects[index], x, y, width, height };
                    }
                } else if (interactionState.type === 'create-redaction') {
                    const touch = e.changedTouches ? e.changedTouches[0] : e;
                    const x1 = (interactionState.startX - canvasRect.left) / scale;
                    const y1 = (interactionState.startY - canvasRect.top) / scale;
                    const x2 = (touch.clientX - canvasRect.left) / scale;
                    const y2 = (touch.clientY - canvasRect.top) / scale;

                    if (Math.abs(x1 - x2) > 5 && Math.abs(y1 - y2) > 5) {
                         redactionAreas.push({
                            originalPageNum: pageNum,
                            x: Math.min(x1, x2),
                            y: Math.min(y1, y2),
                            width: Math.abs(x1 - x2),
                            height: Math.abs(y1 - y2)
                        });
                        await renderRedactionBoxes();
                    }
                    resetTool();
                } else if (interactionState.type === 'create-text') {
                    const touch = e.changedTouches ? e.changedTouches[0] : e;
                    const x = (touch.clientX - canvasRect.left) / scale;
                    const y = (touch.clientY - canvasRect.top) / scale;
                    
                    textObjects.push({
                        originalPageNum: pageNum,
                        text: 'New Text',
                        x, y,
                        width: 50 / scale, height: 14 / scale, // Default size in PDF units
                        fontSize: 12,
                        color: '#000000'
                    });
                    await renderTextObjects();
                    const newBox = pageContainer.querySelector(`.text-box[data-text-index="${textObjects.length - 1}"]`);
                    selectTextBox(newBox);
                    resetTool();
                }
                
                interactionState.type = null;
            }

            const resetTool = () => { activeTool = null; pageContainer.style.cursor = 'default'; };
            const activateTool = (toolName, message) => { activeTool = toolName; alert(message); closeDrawer(); return true; };
            toolAddTextBtn.addEventListener('click', () => activateTool('add-text', 'Tap on a page to add a new text box.'));
            toolRedactBtn.addEventListener('click', () => activateTool('redact', 'Tap and drag on a page to create a redaction area. Tap existing areas to manage them.'));

            // --- Utility Functions ---
            const showLoader = text => { loaderText.textContent = text; loaderOverlay.classList.remove('hidden'); };
            const hideLoader = () => loaderOverlay.classList.add('hidden');
            const downloadBlob = (data, fileName) => {
                const blob = new Blob([data], { type: 'application/pdf' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none'; a.href = url; a.download = fileName;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);
            };
            const hexToRgb = hex => {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? { r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) } : null;
            };
        });
    </script>
</body>
</html>
