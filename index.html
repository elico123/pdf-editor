<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Offline PDF Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .loader { border-top-color: #3498db; -webkit-animation: spin 1s linear infinite; animation: spin 1s linear infinite; }
        @-webkit-keyframes spin { 0% { -webkit-transform: rotate(0deg); } 100% { -webkit-transform: rotate(360deg); } }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #page-container canvas { box-shadow: 0 4px 12px rgba(0,0,0,0.15); margin-bottom: 1rem; }
        .thumbnail-item { border: 2px solid transparent; transition: border-color 0.2s; }
        .thumbnail-item.selected { border-color: #3b82f6; }
        .sortable-ghost { opacity: 0.4; background: #c7d2fe; }
        .redaction-box { position: absolute; border: 2px dashed red; background-color: rgba(255, 0, 0, 0.3); }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 flex flex-col h-screen">

    <!-- Header -->
    <header class="bg-white shadow-md p-4 flex items-center justify-between z-10">
        <h1 class="text-xl md:text-2xl font-bold text-gray-800">PDF Editor</h1>
        <div class="flex items-center space-x-2">
            <input type="file" id="file-input" class="hidden" accept="application/pdf" multiple>
            <button id="open-pdf-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg transition duration-300">Open PDF</button>
            <button id="save-pdf-btn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition duration-300 hidden">Save</button>
            <button id="print-pdf-btn" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg transition duration-300 hidden">Print</button>
        </div>
    </header>

    <!-- Main Content -->
    <main class="flex-1 flex flex-col md:flex-row overflow-hidden">
        <!-- Sidebar -->
        <aside id="sidebar" class="w-full md:w-64 bg-white p-4 overflow-y-auto border-r border-gray-200 transition-all duration-300 hidden">
            <h2 class="text-lg font-semibold mb-4">Tools & Pages</h2>
            
            <!-- Tools -->
            <div class="space-y-2 mb-6">
                <button id="tool-merge" class="w-full text-left bg-gray-200 hover:bg-gray-300 text-gray-700 font-semibold py-2 px-4 rounded-lg transition">Merge Documents</button>
                <button id="tool-split" class="w-full text-left bg-gray-200 hover:bg-gray-300 text-gray-700 font-semibold py-2 px-4 rounded-lg transition">Split Document</button>
                <button id="tool-add-text" class="w-full text-left bg-gray-200 hover:bg-gray-300 text-gray-700 font-semibold py-2 px-4 rounded-lg transition">Add Text</button>
                <button id="tool-redact" class="w-full text-left bg-gray-200 hover:bg-gray-300 text-gray-700 font-semibold py-2 px-4 rounded-lg transition">Redact</button>
            </div>

            <!-- Pages -->
            <h3 class="text-md font-semibold mb-2">Pages (Drag to Sort)</h3>
            <div id="thumbnails-container" class="space-y-2">
                <!-- Thumbnails will be injected here -->
            </div>
        </aside>

        <!-- PDF Viewer -->
        <div id="viewer-container" class="flex-1 bg-gray-200 p-4 overflow-y-auto flex items-center justify-center">
            <div id="welcome-message" class="text-center">
                <svg class="mx-auto h-12 w-12 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true">
                    <path vector-effect="non-scaling-stroke" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                </svg>
                <h3 class="mt-2 text-sm font-medium text-gray-900">No PDF selected</h3>
                <p class="mt-1 text-sm text-gray-500">Get started by opening a PDF file.</p>
            </div>
            <div id="page-container" class="relative">
                <!-- PDF pages will be rendered here -->
            </div>
        </div>
    </main>

    <!-- Modal/Loader -->
    <div id="loader-overlay" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="loader ease-linear rounded-full border-8 border-t-8 border-gray-200 h-32 w-32"></div>
        <p id="loader-text" class="text-white text-lg ml-4">Loading...</p>
    </div>
    
    <!-- Service Worker Registration -->
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/service-worker.js')
                    .then(registration => console.log('ServiceWorker registration successful with scope: ', registration.scope))
                    .catch(error => console.log('ServiceWorker registration failed: ', error));
            });
        }
    </script>
    
    <script>
        // PDF.js worker configuration
        pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js`;
        
        // DOM Elements
        const fileInput = document.getElementById('file-input');
        const openPdfBtn = document.getElementById('open-pdf-btn');
        const savePdfBtn = document.getElementById('save-pdf-btn');
        const printPdfBtn = document.getElementById('print-pdf-btn');
        const sidebar = document.getElementById('sidebar');
        const viewerContainer = document.getElementById('viewer-container');
        const pageContainer = document.getElementById('page-container');
        const thumbnailsContainer = document.getElementById('thumbnails-container');
        const welcomeMessage = document.getElementById('welcome-message');
        const loaderOverlay = document.getElementById('loader-overlay');
        const loaderText = document.getElementById('loader-text');
        
        // Tool Buttons
        const toolMergeBtn = document.getElementById('tool-merge');
        const toolSplitBtn = document.getElementById('tool-split');
        const toolAddTextBtn = document.getElementById('tool-add-text');
        const toolRedactBtn = document.getElementById('tool-redact');

        // App State
        let pdfDoc = null;
        let pdfBytes = null;
        let pageOrder = [];
        let currentPage = 1;
        let activeTool = null;
        let redactionAreas = [];

        // --- CORE PDF HANDLING ---

        const loadPdf = async (file) => {
            showLoader('Loading PDF...');
            const arrayBuffer = await file.arrayBuffer();
            pdfBytes = new Uint8Array(arrayBuffer);
            pdfDoc = await pdfjsLib.getDocument({ data: pdfBytes }).promise;
            
            pageOrder = Array.from({ length: pdfDoc.numPages }, (_, i) => i + 1);
            
            welcomeMessage.classList.add('hidden');
            pageContainer.innerHTML = '';
            thumbnailsContainer.innerHTML = '';
            sidebar.classList.remove('hidden');
            savePdfBtn.classList.remove('hidden');
            printPdfBtn.classList.remove('hidden');

            await renderAllPages();
            await renderThumbnails();
            
            hideLoader();
        };

        const renderPage = async (pageNum, container) => {
            const page = await pdfDoc.getPage(pageNum);
            const viewport = page.getViewport({ scale: 1.5 });
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.height = viewport.height;
            canvas.width = viewport.width;
            canvas.dataset.pageNum = pageNum;
            
            const renderContext = {
                canvasContext: context,
                viewport: viewport
            };
            await page.render(renderContext).promise;
            container.appendChild(canvas);
            return canvas;
        };

        const renderAllPages = async () => {
            pageContainer.innerHTML = '';
            showLoader('Rendering pages...');
            for (const pageNum of pageOrder) {
                await renderPage(pageNum, pageContainer);
            }
            hideLoader();
        };
        
        const renderThumbnails = async () => {
            thumbnailsContainer.innerHTML = '';
            for (let i = 0; i < pageOrder.length; i++) {
                const pageNum = pageOrder[i];
                const page = await pdfDoc.getPage(pageNum);
                const viewport = page.getViewport({ scale: 0.3 });
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.height = viewport.height;
                canvas.width = viewport.width;

                const renderContext = {
                    canvasContext: context,
                    viewport: viewport
                };
                await page.render(renderContext).promise;
                
                const thumbItem = document.createElement('div');
                thumbItem.classList.add('thumbnail-item', 'p-1', 'rounded-md', 'cursor-pointer', 'relative');
                thumbItem.dataset.originalIndex = pageNum;
                thumbItem.dataset.currentIndex = i;
                
                const pageNumberLabel = document.createElement('span');
                pageNumberLabel.textContent = i + 1;
                pageNumberLabel.classList.add('absolute', 'top-1', 'left-1', 'bg-blue-500', 'text-white', 'text-xs', 'font-bold', 'px-1.5', 'py-0.5', 'rounded');
                
                thumbItem.appendChild(canvas);
                thumbItem.appendChild(pageNumberLabel);
                thumbnailsContainer.appendChild(thumbItem);
            }
        };

        // --- EVENT LISTENERS ---

        openPdfBtn.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', async (e) => {
            if (e.target.files.length > 0) {
                if(activeTool === 'merge') {
                    await handleMerge(e.target.files);
                    activeTool = null;
                } else {
                    await loadPdf(e.target.files[0]);
                }
            }
        });

        savePdfBtn.addEventListener('click', async () => {
            showLoader('Saving PDF...');
            const { PDFDocument } = PDFLib;
            const newPdfDoc = await PDFDocument.load(pdfBytes);
            const pages = await newPdfDoc.copyPages(newPdfDoc, pageOrder.map(p => p - 1));
            
            const finalDoc = await PDFDocument.create();
            for(const page of pages) {
                finalDoc.addPage(page);
            }

            // Apply redactions if any
            if (redactionAreas.length > 0) {
                const { rgb, StandardFonts } = PDFLib;
                for (const area of redactionAreas) {
                    const page = finalDoc.getPage(area.pageIndex);
                    page.drawRectangle({
                        x: area.x,
                        y: area.y,
                        width: area.width,
                        height: area.height,
                        color: rgb(0, 0, 0),
                    });
                }
            }

            const finalPdfBytes = await finalDoc.save();
            const blob = new Blob([finalPdfBytes], { type: 'application/pdf' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `edited-${fileInput.files[0]?.name || 'document.pdf'}`;
            link.click();
            hideLoader();
        });

        printPdfBtn.addEventListener('click', () => {
            // A simplified print. For full accuracy, we'd save and print the new blob.
            window.print();
        });

        // --- TOOLS ---
        
        // Sorting with SortableJS
        new Sortable(thumbnailsContainer, {
            animation: 150,
            ghostClass: 'sortable-ghost',
            onEnd: async (evt) => {
                const element = pageOrder.splice(evt.oldIndex, 1)[0];
                pageOrder.splice(evt.newIndex, 0, element);
                showLoader('Reordering pages...');
                await renderAllPages();
                await renderThumbnails(); // To update numbering
                hideLoader();
            }
        });

        // Merge
        toolMergeBtn.addEventListener('click', () => {
            if (!pdfDoc) {
                alert('Please open a base PDF first.');
                return;
            }
            activeTool = 'merge';
            alert('Select additional PDF files to merge.');
            fileInput.click();
        });
        
        const handleMerge = async (filesToMerge) => {
            showLoader('Merging PDFs...');
            const { PDFDocument } = PDFLib;
            const mergedPdf = await PDFDocument.load(pdfBytes);

            for (const file of filesToMerge) {
                const bytes = await file.arrayBuffer();
                const docToMerge = await PDFDocument.load(bytes);
                const pages = await mergedPdf.copyPages(docToMerge, docToMerge.getPageIndices());
                pages.forEach(page => mergedPdf.addPage(page));
            }

            pdfBytes = await mergedPdf.save();
            pdfDoc = await pdfjsLib.getDocument({ data: pdfBytes }).promise;
            pageOrder = Array.from({ length: pdfDoc.numPages }, (_, i) => i + 1);
            
            await renderAllPages();
            await renderThumbnails();
            hideLoader();
        };

        // Split
        toolSplitBtn.addEventListener('click', async () => {
            if (!pdfDoc) return;
            const splitIndexStr = prompt(`Enter page number to split AFTER (1-${pageOrder.length}):`);
            const splitIndex = parseInt(splitIndexStr);
            
            if (isNaN(splitIndex) || splitIndex <= 0 || splitIndex >= pageOrder.length) {
                alert('Invalid split point.');
                return;
            }

            showLoader('Splitting PDF...');
            const { PDFDocument } = PDFLib;

            // Create first part
            const firstDoc = await PDFDocument.create();
            const baseDoc1 = await PDFDocument.load(pdfBytes);
            const firstPagesIndices = pageOrder.slice(0, splitIndex).map(p => p - 1);
            const firstPages = await firstDoc.copyPages(baseDoc1, firstPagesIndices);
            firstPages.forEach(p => firstDoc.addPage(p));
            const firstBytes = await firstDoc.save();
            downloadBlob(firstBytes, `part1-${fileInput.files[0].name}`);

            // Create second part
            const secondDoc = await PDFDocument.create();
            const baseDoc2 = await PDFDocument.load(pdfBytes);
            const secondPagesIndices = pageOrder.slice(splitIndex).map(p => p - 1);
            const secondPages = await secondDoc.copyPages(baseDoc2, secondPagesIndices);
            secondPages.forEach(p => secondDoc.addPage(p));
            const secondBytes = await secondDoc.save();
            downloadBlob(secondBytes, `part2-${fileInput.files[0].name}`);
            
            hideLoader();
        });

        // Add Text
        toolAddTextBtn.addEventListener('click', () => {
            if (!pdfDoc) return;
            activeTool = 'add-text';
            alert('Click on a page to add text.');
            pageContainer.style.cursor = 'crosshair';
        });

        // Redact
        toolRedactBtn.addEventListener('click', () => {
            if (!pdfDoc) return;
            activeTool = 'redact';
            alert('Click and drag on a page to create a redaction area.');
            pageContainer.style.cursor = 'crosshair';
            redactionAreas = []; // Clear previous
        });

        // Handle clicks on page for tools
        pageContainer.addEventListener('mousedown', async (e) => {
            if (!activeTool || !e.target.matches('canvas')) return;

            const canvas = e.target;
            const rect = canvas.getBoundingClientRect();
            const pageNum = parseInt(canvas.dataset.pageNum);
            const pageIndex = pageOrder.indexOf(pageNum);
            const page = await pdfDoc.getPage(pageNum);
            const viewport = page.getViewport({ scale: 1.5 });
            
            // Convert click coordinates to PDF coordinates
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const pdfX = (x / viewport.width) * page.viewBox[2];
            const pdfY = (1 - y / viewport.height) * page.viewBox[3];

            if (activeTool === 'add-text') {
                const text = prompt('Enter text to add:');
                if (text) {
                    showLoader('Adding text...');
                    const { PDFDocument, rgb, StandardFonts } = PDFLib;
                    const pdfLibDoc = await PDFDocument.load(pdfBytes);
                    const helveticaFont = await pdfLibDoc.embedFont(StandardFonts.Helvetica);
                    const pages = pdfLibDoc.getPages();
                    const targetPage = pages[pageIndex];
                    
                    targetPage.drawText(text, {
                        x: pdfX,
                        y: pdfY,
                        font: helveticaFont,
                        size: 12,
                        color: rgb(0, 0, 0),
                    });

                    pdfBytes = await pdfLibDoc.save();
                    await loadPdfFromBytes(pdfBytes); // Reload to show changes
                    hideLoader();
                }
                resetTool();
            } else if (activeTool === 'redact') {
                const startX = e.clientX;
                const startY = e.clientY;
                const redactionBox = document.createElement('div');
                redactionBox.classList.add('redaction-box');
                pageContainer.appendChild(redactionBox);

                const onMouseMove = (moveE) => {
                    const currentX = moveE.clientX;
                    const currentY = moveE.clientY;
                    const left = Math.min(startX, currentX) - rect.left;
                    const top = Math.min(startY, currentY) - rect.top;
                    const width = Math.abs(currentX - startX);
                    const height = Math.abs(currentY - startY);
                    redactionBox.style.left = `${left}px`;
                    redactionBox.style.top = `${top}px`;
                    redactionBox.style.width = `${width}px`;
                    redactionBox.style.height = `${height}px`;
                };

                const onMouseUp = (upE) => {
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                    
                    const boxRect = redactionBox.getBoundingClientRect();
                    const pdfStartX = (boxRect.left - rect.left) / viewport.width * page.viewBox[2];
                    const pdfStartY = (1 - (boxRect.top - rect.top + boxRect.height) / viewport.height) * page.viewBox[3];
                    const pdfWidth = boxRect.width / viewport.width * pag
